package com.example.accessingdatamysql;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Optional;

import org.hibernate.internal.build.AllowSysOut;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
//import org.springframework.format.annotation.DateTimeFormat;

@Controller // This means that this class is a Controller
@RequestMapping(path = "/employee") // This means URL's start with /demo (after Application path)
public class EmployeeController {

	@Autowired // This means to get the bean called userRepository
				// Which is auto-generated by Spring, we will use it to handle the data
	private EmployeeRepository employeeRepository;

	@Autowired
	private DepartmentRepository departmentRepository;

	@Autowired
	private AddressRepository addressRepository;

	@Autowired
	private SalaryRepository salaryRepository;

	@Autowired
	private PaymentsRepository paymentRepository;

	@Autowired
	private LeavesRepository leavesRepository;

	@DateTimeFormat(pattern = "yyyy-MM-dd")
	private Date doj;

	private QueryService myService;

	@Autowired
	public EmployeeController(QueryService myService) {
		this.myService = myService;
	}

	@PostMapping(path = "/create") // Map ONLY POST Requests
	public String addNewEmployee(@RequestParam String name, @RequestParam String depName, @RequestParam String salary,
			Model model) {
		// @RequestParam String city,@RequestParam Date doj,
		// @RequestParam String street, @RequestParam String state, @RequestParam String
		// leavesTaken
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		System.out.println("entered the create Employee method");
		Employee emp = new Employee();
		// int idNum = Integer.parseInt(id);
		// emp.setId(idNum);
		emp.setName(name);

		System.out.println("depName is : " + depName);
		Department dep = new Department();

		dep.setName(depName);
		departmentRepository.save(dep);

		Address address = new Address();
		// address.setStreet(street);
		// address.setCity(city);
		// address.setState(state);
		addressRepository.save(address);

		Salary salObj = new Salary();
		// int leaves = Integer.parseInt(leavesTaken);
		int sal = Integer.parseInt(salary);

		// salObj.setLeavesTaken((long) leaves);
		// salObj.setDoj(doj);
		salObj.setSalary((long) sal);
		salaryRepository.save(salObj);

		emp.setDepartment(dep);
		emp.setAddress(address);
		emp.setSalary(salObj);
		employeeRepository.save(emp);
		System.out.println("Employee has been created!");
		model.addAttribute("employee", emp);

		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("reqHtml", "Employee with the name " + name + "  has been created!");
		model.addAttribute("employeeList", jsonObj);
		return "emplist";
	}

	@GetMapping(path = "/create")
	public String greetingForm(Model model) {
		System.out.println("inside get create employee method");
		model.addAttribute("employee", new Employee());
		return "empcreate";
	}

	@GetMapping(path = "/emplist")
	public String listUsers(Model model) {
		System.out.println("inside the employee list controller methods");
		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		return "emplist";
	}

	@GetMapping(path = "/all-sals")
	public String allSals(Model model) {
		System.out.println("inside the salaries list controller methods");
		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		return "all-sals";
	}

	private long getTotalSalaries(String item) {
		ArrayList<Employee> allEmployees = (ArrayList<Employee>) employeeRepository.findAll();
		long salTotal = 0;
		for (Iterator<Employee> iterator = allEmployees.iterator(); iterator.hasNext();) {
			Employee employee = (Employee) iterator.next();
			Salary sal = employee.getSalary();
			if (item.equalsIgnoreCase("sal"))
				salTotal = salTotal + sal.getSalaryForCurrentMonth();
			else if (item.equalsIgnoreCase("tax"))
				salTotal = salTotal + (sal.getSalaryForCurrentMonth() * sal.getTaxSlabPercent() / 100);
			else if (item.equalsIgnoreCase("salAfter"))
				salTotal = salTotal + (sal.getSalaryForCurrentMonth()
						- (sal.getSalaryForCurrentMonth() * sal.getTaxSlabPercent() / 100));
		}

		return salTotal;
	}

	@GetMapping(path = "/sal-gen")
	public String salGen(Model model) {
		System.out.println("inside the salaries list controller methods");
		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		long totSals = getTotalSalaries("sal");
		long totTax = getTotalSalaries("tax");
		long totSalAfterTax = getTotalSalaries("salAfter");
		model.addAttribute("employeeList", jsonObj);
		model.addAttribute("totSals", totSals);
		model.addAttribute("totTax", totTax);
		model.addAttribute("totSalAfterTax", totSalAfterTax);
		return "sal-gen";
	}

	@GetMapping(path = "/list-salaries")
	public String listSalaries(Model model) {
		System.out.println("inside the LIST salaries  controller methods");
		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		long totSals = getTotalSalaries("sal");
		long totTax = getTotalSalaries("tax");
		long totSalAfterTax = getTotalSalaries("salAfter");
		model.addAttribute("employeeList", jsonObj);
		model.addAttribute("totSals", totSals);
		model.addAttribute("totTax", totTax);
		model.addAttribute("totSalAfterTax", totSalAfterTax);
		return "list-salaries";
	}

	@PostMapping(path = "/list-salaries")
	public String listSalariesPost(@RequestParam int year, @RequestParam int month, Model model) {
		long totSals = 0;
		long totTax = 0;
		long totSalAfterTax = 0;
		System.out.println("inside the listSalariesPost method | year | month :::: " + year + "| " + month);
		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		List<PaymentsTable> paymentData = paymentRepository.findAll();
		List<Employee> empData = employeeRepository.findAll();
		List<SalaryExporter> salExporterList = new ArrayList<SalaryExporter>();
		for (Iterator<Employee> iterator = empData.iterator(); iterator.hasNext();) {
			Employee emp = (Employee) iterator.next();
			List<Long> queryResults = myService.executeQuery(emp.getId(), month, year);
			System.out.println("queryResults is : " + queryResults);
			if (queryResults.size() > 0) {
				SalaryExporter salExp = new SalaryExporter();
				long paymentId = queryResults.get(0);
				Optional<PaymentsTable> pT = paymentRepository.findById(paymentId);
				PaymentsTable currentPayment = pT.get();
				salExp.setEmployeeID(currentPayment.getEmpId());
				salExp.setEmpName(emp.getName());
				salExp.setSalaryForCurrentMonth(currentPayment.getSalaryForCurrentMonth());
				salExp.setTds(currentPayment.getTds());
				salExp.setSalAfterAllDeductions(currentPayment.getSalAfterAllDeductions());
				salExporterList.add(salExp);
				totSals = totSals + currentPayment.getSalaryForCurrentMonth();
				totTax = totTax + currentPayment.getTds();
				totSalAfterTax = totSalAfterTax + currentPayment.getSalAfterAllDeductions();
			}
		}
		model.addAttribute("totSals", totSals);
		model.addAttribute("totTax", totTax);
		model.addAttribute("totSalAfterTax", totSalAfterTax);
		model.addAttribute("reqPaymentData", salExporterList);
		return "list-salaries";
	}

	@GetMapping(path = "/updatesalary")
	public String updateSalary(@RequestParam long id, Model model) {
		System.out.println("inside the update salary controller method");
		model.addAttribute("employee", new Employee());
		Optional<Employee> empData = employeeRepository.findById(id);
		Employee currentEmp = empData.get();
		model.addAttribute("empDetails", currentEmp);
		System.out.println("department name is : " + currentEmp.getDepartment().getName());
		model.addAttribute("depDetails", currentEmp.getDepartment());
		return "updatesalary";
	}

	@GetMapping(path = "/emp-getsal")
	public String empGetSalary(@RequestParam long id, Model model) {
		System.out.println("inside the update salary controller method");
		List<PaymentsTable> paymentData = paymentRepository.findAll();
		List<PaymentsTable> reqPaymentData = new ArrayList<PaymentsTable>();
		for (Iterator<PaymentsTable> iterator = paymentData.iterator(); iterator.hasNext();) {
			PaymentsTable paymentsTable = (PaymentsTable) iterator.next();
			System.out.println("paymentsTable.getEmpId() is : " + paymentsTable.getEmpId());
			boolean test = paymentsTable.getEmpId() == id;
			System.out.println("test is : " + test);
			if (paymentsTable.getEmpId() == id)
				reqPaymentData.add(paymentsTable);
		}
		model.addAttribute("reqPaymentData", reqPaymentData);
		return "emp-getsal";
	}

	@GetMapping(path = "/emp-leave")
	public String empLeave(@RequestParam long id, Model model) {
		Optional<Employee> empData = employeeRepository.findById(id);
		List<LeavesTable> leavesData = leavesRepository.findAll();
		List<LeavesTable> reqLeavesData = new ArrayList<LeavesTable>();
		for (Iterator<LeavesTable> iterator = leavesData.iterator(); iterator.hasNext();) {
			LeavesTable leavesTable = (LeavesTable) iterator.next();
			System.out.println("paymentsTable.getEmpId() is : " + leavesTable.getEmpId());
			if (leavesTable.getEmpId() == id)
				reqLeavesData.add(leavesTable);
		}
		Employee currentEmp = empData.get();
		model.addAttribute("empDetails", currentEmp);
		model.addAttribute("reqLeavesData", reqLeavesData);
		updateLeavesCountPerMonth(reqLeavesData, 9);
		return "emp-leave";
	}

	private void updateLeavesCountPerMonth(List<LeavesTable> reqLeavesData, int monthNum) {
		int totLeavesInMonth = 0;

		for (Iterator<LeavesTable> iterator = reqLeavesData.iterator(); iterator.hasNext();) {
			LeavesTable leavesTable = (LeavesTable) iterator.next();
			System.out.println("for the id : " + leavesTable.getEmpId());
			String leaveFrom = leavesTable.getLeaveFrom();
			String leaveTo = leavesTable.getLeaveTo();
			int monthLF = Integer.parseInt((leaveFrom).split("-")[1]);
			int monthLT = Integer.parseInt((leaveTo).split("-")[1]);
			if (monthLF == monthNum || monthLT == monthNum) {
				System.out.println("monthLF : " + monthLF);
				System.out.println("1111 : totLeavesInMonth " + totLeavesInMonth);
				totLeavesInMonth = totLeavesInMonth + getLeavesCount(leaveFrom, leaveTo);
				System.out.println("2222 : totLeavesInMonth " + totLeavesInMonth);
			}

		}
		System.out.println("Tot Leaves in the month : " + monthNum + " is :::::: " + totLeavesInMonth);

	}

	@PostMapping(path = "/emp-leave")
	public String updateLeaves(@RequestParam long id, @RequestParam String leaveFrom, @RequestParam String leaveTo,
			Model model) {
		System.out.println("inside the Leaves controller method");
		System.out.println("leaveFrom : leaveTo :::: " + leaveFrom + " : " + leaveTo);
		long leavesCount = getLeavesCount(leaveFrom, leaveTo);
		long monthNum = 1;
		long yearNum = 2023;
		LeavesTable leavesTable = new LeavesTable();
		leavesTable.setEmpId(id);
		leavesTable.setLeaveFrom(leaveFrom);
		leavesTable.setLeaveTo(leaveTo);
		leavesTable.setMonthNumber(monthNum);
		leavesTable.setYearNumber(yearNum);
		leavesTable.setLeavesCount(leavesCount);
		Optional<Employee> empData = employeeRepository.findById(id);
		Employee currentEmp = empData.get();
		model.addAttribute("empDetails", currentEmp);
		leavesRepository.save(leavesTable);
		return "emp-leave";

	}

	private int getLeavesCount(String leaveFrom, String leaveTo) {
		// TO DO - write code to find out the working days between these dates!
		Calendar frmCalendar = getCalendarObj(leaveFrom);
		Calendar toCalendar = getCalendarObj(leaveTo);
		int workingDays = 0;
		System.out.println("frmCalendar.get(Calendar.MONTH) is : " + frmCalendar.get(Calendar.MONTH));
		System.out.println("toCalendar.get(Calendar.MONTH) is : " + toCalendar.get(Calendar.MONTH));
		while (toCalendar.get(Calendar.MONTH) >= frmCalendar.get(Calendar.MONTH)) {
			if (toCalendar.get(Calendar.MONTH) > frmCalendar.get(Calendar.MONTH)) {
				int dayOfWeek = frmCalendar.get(Calendar.DAY_OF_WEEK);
				if (dayOfWeek != Calendar.SATURDAY && dayOfWeek != Calendar.SUNDAY) {
					workingDays++;
				}
				frmCalendar.add(Calendar.DAY_OF_MONTH, 1);
			} else {
				if (toCalendar.get(Calendar.DATE) >= frmCalendar.get(Calendar.DATE)) {
					int dayOfWeek = frmCalendar.get(Calendar.DAY_OF_WEEK);
					if (dayOfWeek != Calendar.SATURDAY && dayOfWeek != Calendar.SUNDAY) {
						workingDays++;
					}
					frmCalendar.add(Calendar.DAY_OF_MONTH, 1);
				} else {
					break;
				}

			}

		}
		System.out.println("workingDays are : " + workingDays);

		return workingDays;
	}

	private static Calendar getCalendarObj(String dateStr) {
		// dateStr in the format of "2023-09-21"
		String[] str = dateStr.split("-");
		String year = str[0];
		String month = str[1];
		String date = str[2];
		int yearNum = Integer.parseInt(year);
		int monthNum = Integer.parseInt(month);
		int dateNum = Integer.parseInt(date);
		String breakPt = " : ";
		System.out.println("year : month : date : " + year + breakPt + month + breakPt + date);
		Calendar calendar = Calendar.getInstance();
		calendar.set(yearNum, monthNum - 1, dateNum);
		return calendar;
	}

	@PostMapping(path = "/updatesalary")
	public String updateProfilePost(@ModelAttribute Employee empFrmReq, @RequestParam long leavesTaken,
			@RequestParam String depName, @RequestParam long availableLeaves, @RequestParam long taxSlabPercent,
			@RequestParam long yearNum, @RequestParam long monthNum, Model model) {
		System.out.println("From the request object empFrmReq : name " + empFrmReq.getName());
		System.out.println("From the request object leavesTaken : leavesTaken " + leavesTaken);

		Optional<Employee> empData = employeeRepository.findById((long) empFrmReq.getId());
		Employee currentEmp = empData.get();
		Salary currentSalary = currentEmp.getSalary();
		currentSalary.setAvailableLeaves(availableLeaves);
		long currentMonthSalary = currentSalary.getSalary();
		currentEmp.setName(empFrmReq.getName());
		currentEmp.getDepartment().setName(depName);
		currentSalary.setLeavesTaken(leavesTaken);
		long numOfDaysInMonth = 30;
		long totLeavesAvailable = availableLeaves;// currentSalary.getAvailableLeaves();
		totLeavesAvailable = totLeavesAvailable - leavesTaken;
		long perDaySal = currentMonthSalary / numOfDaysInMonth;
		if (totLeavesAvailable < 0) {
			long salDays = numOfDaysInMonth + totLeavesAvailable;
			currentMonthSalary = perDaySal * salDays;
		}
		currentSalary.setSalaryForCurrentMonth(currentMonthSalary);
		long tds = taxSlabPercent; // currentSalary.getTaxSlabPercent();
		currentSalary.setTaxSlabPercent(taxSlabPercent);
		long currentMonthSalAfterTax = currentMonthSalary - (currentMonthSalary * tds / 100);
		currentSalary.setSalAfterAllDeductions(currentMonthSalAfterTax);
		employeeRepository.save(currentEmp);

		updatePaymentsTable(currentEmp, yearNum, monthNum);

		ArrayList<Employee> jsonObj = (ArrayList<Employee>) employeeRepository.findAll();
		model.addAttribute("employeeList", jsonObj);
		return "sal-gen";
	}

	private void updatePaymentsTable(Employee currentEmp, long yearNum, long monthNum) {
		System.out.println("insde payments update table");
		PaymentsTable paymentsTable = new PaymentsTable();
		paymentsTable.setEmpId(currentEmp.getId());
		paymentsTable.setMonthNumber(monthNum);
		paymentsTable.setYearNumber(yearNum);
		Salary sal = currentEmp.getSalary();
		paymentsTable.setSalaryForCurrentMonth(sal.getSalaryForCurrentMonth());
		paymentsTable.setSalAfterAllDeductions(sal.getSalAfterAllDeductions());
		paymentsTable.setTds(sal.getTaxSlabPercent() * sal.getSalaryForCurrentMonth() / 100);
		paymentsTable.setNumOfLeavesTakenInAMonth(sal.getLeavesTaken());
		paymentRepository.save(paymentsTable);

	}
}
